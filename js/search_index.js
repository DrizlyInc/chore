var search_data = {"index":{"searchIndex":["chore","cli","configuration","consumer","duplicatedetector","filesystemconsumer","filesystempublisher","filesystemqueue","forkedworkerstrategy","hooks","job","classmethods","rejectmessageexception","jsonencoder","lease","lockingsqsconsumer","manager","pipe","pipelistener","pipedstats","publisher","sqsconsumer","sqspublisher","semaphore","singleconsumerstrategy","singleworkerstrategy","stats","tapjoy","threadedconsumerstrategy","unitofwork","util","version","worker","workerlistener","newrelic","agent","instrumentation","choreinstrumenthook","object","acquire()","add()","add()","add_hook()","add_pipe()","assign()","assign()","assign()","available?()","close()","close_all()","closed?()","complete()","complete()","complete()","config()","configure()","constantize()","consume()","consume()","consume()","consume()","decode()","encode()","encode_job()","end_pipe()","ensure_queue!()","fetch()","fetch()","filename()","found_duplicate?()","get()","handle_payload()","handle_payload()","hooks_for()","in_progress_dir()","job_hash()","merge_hash()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new_dir()","payload_class()","payload_class()","perform()","perform()","perform_async()","perform_async()","pipe_from_handle()","prune!()","publish()","publish()","publish()","publish()","queue_dir()","queue_options()","read()","register_option()","register_tapjoy_handlers!()","reject()","reject()","reject()","release()","report()","required_options()","root_dir()","run!()","run_hooks_for()","run_hooks_for()","running?()","running?()","set_worker_status()","should_stop?()","shutdown()","shutdown!()","start()","start()","start()","start()","start()","stop()","stop()","stop!()","stop!()","stop!()","stop!()","to_json()","to_json()","wake_up!()","workers_available?()","workers_available?()","write()","readme"],"longSearchIndex":["chore","chore::cli","chore::configuration","chore::consumer","chore::duplicatedetector","chore::filesystemconsumer","chore::filesystempublisher","chore::filesystemqueue","chore::forkedworkerstrategy","chore::hooks","chore::job","chore::job::classmethods","chore::job::rejectmessageexception","chore::jsonencoder","chore::lease","chore::lockingsqsconsumer","chore::manager","chore::pipe","chore::pipelistener","chore::pipedstats","chore::publisher","chore::sqsconsumer","chore::sqspublisher","chore::semaphore","chore::singleconsumerstrategy","chore::singleworkerstrategy","chore::stats","chore::tapjoy","chore::threadedconsumerstrategy","chore::unitofwork","chore::util","chore::version","chore::worker","chore::workerlistener","newrelic","newrelic::agent","newrelic::agent::instrumentation","newrelic::agent::instrumentation::choreinstrumenthook","object","chore::semaphore#acquire()","chore::pipedstats#add()","chore::stats#add()","chore::add_hook()","chore::pipelistener#add_pipe()","chore::forkedworkerstrategy#assign()","chore::manager#assign()","chore::singleworkerstrategy#assign()","chore::semaphore#available?()","chore::pipe#close()","chore::pipelistener#close_all()","chore::pipe#closed?()","chore::consumer#complete()","chore::filesystemconsumer#complete()","chore::sqsconsumer#complete()","chore::config()","chore::configure()","chore::util#constantize()","chore::consumer#consume()","chore::filesystemconsumer#consume()","chore::lockingsqsconsumer#consume()","chore::sqsconsumer#consume()","chore::jsonencoder::decode()","chore::jsonencoder::encode()","chore::publisher#encode_job()","chore::pipelistener#end_pipe()","chore::sqspublisher#ensure_queue!()","chore::singleconsumerstrategy#fetch()","chore::threadedconsumerstrategy#fetch()","chore::filesystempublisher#filename()","chore::duplicatedetector#found_duplicate?()","chore::stats#get()","chore::pipelistener#handle_payload()","chore::workerlistener#handle_payload()","chore::hooks_for()","chore::filesystemqueue#in_progress_dir()","chore::job::classmethods#job_hash()","chore::configuration#merge_hash()","chore::cli::new()","chore::consumer::new()","chore::duplicatedetector::new()","chore::filesystemconsumer::new()","chore::forkedworkerstrategy::new()","chore::job::new()","chore::lease::new()","chore::lockingsqsconsumer::new()","chore::manager::new()","chore::pipe::new()","chore::pipelistener::new()","chore::pipedstats::new()","chore::publisher::new()","chore::sqsconsumer::new()","chore::sqspublisher::new()","chore::semaphore::new()","chore::singleconsumerstrategy::new()","chore::singleworkerstrategy::new()","chore::stats::new()","chore::threadedconsumerstrategy::new()","chore::worker::new()","chore::workerlistener::new()","object::new()","chore::filesystemqueue#new_dir()","chore::worker#payload_class()","newrelic::agent::instrumentation::choreinstrumenthook#payload_class()","chore::job#perform()","chore::job::classmethods#perform()","chore::job#perform_async()","chore::job::classmethods#perform_async()","chore::pipelistener#pipe_from_handle()","chore::pipelistener#prune!()","chore::filesystempublisher#publish()","chore::publisher::publish()","chore::publisher#publish()","chore::sqspublisher#publish()","chore::filesystemqueue#queue_dir()","chore::job::classmethods#queue_options()","chore::pipe#read()","chore::cli::register_option()","chore::tapjoy::register_tapjoy_handlers!()","chore::consumer#reject()","chore::filesystemconsumer#reject()","chore::sqsconsumer#reject()","chore::lease#release()","chore::manager#report()","chore::job::classmethods#required_options()","chore::filesystemqueue#root_dir()","chore::cli#run!()","chore::run_hooks_for()","chore::hooks#run_hooks_for()","chore::consumer#running?()","chore::threadedconsumerstrategy#running?()","chore::pipedstats#set_worker_status()","chore::pipelistener#should_stop?()","chore::cli#shutdown()","chore::manager#shutdown!()","chore::forkedworkerstrategy#start()","chore::manager#start()","chore::pipelistener#start()","chore::singleworkerstrategy#start()","chore::worker#start()","chore::consumer#stop()","chore::pipelistener#stop()","chore::forkedworkerstrategy#stop!()","chore::singleconsumerstrategy#stop!()","chore::threadedconsumerstrategy#stop!()","chore::worker#stop!()","chore::stats#to_json()","chore::worker#to_json()","chore::pipelistener#wake_up!()","chore::forkedworkerstrategy#workers_available?()","chore::singleworkerstrategy#workers_available?()","chore::pipe#write()",""],"info":[["Chore","","classes/Chore.html","",""],["Chore::CLI","","classes/Chore/CLI.html","",""],["Chore::Configuration","","classes/Chore/Configuration.html","","<p>Wrapper around an OpenStruct to define configuration data (TODO): Add\nrequired opts, and validate that …\n"],["Chore::Consumer","","classes/Chore/Consumer.html","",""],["Chore::DuplicateDetector","","classes/Chore/DuplicateDetector.html","",""],["Chore::FilesystemConsumer","","classes/Chore/FilesystemConsumer.html","","<p>This is the consuming side of the file system queue. This class consumes\njobs created by FilesystemPublisher#publish …\n"],["Chore::FilesystemPublisher","","classes/Chore/FilesystemPublisher.html","",""],["Chore::FilesystemQueue","","classes/Chore/FilesystemQueue.html","","<p>Common methods used by FilesystemConsumer and FilesystemPublisher for\ndealing with the directories which …\n"],["Chore::ForkedWorkerStrategy","","classes/Chore/ForkedWorkerStrategy.html","",""],["Chore::Hooks","","classes/Chore/Hooks.html","",""],["Chore::Job","","classes/Chore/Job.html","",""],["Chore::Job::ClassMethods","","classes/Chore/Job/ClassMethods.html","",""],["Chore::Job::RejectMessageException","","classes/Chore/Job/RejectMessageException.html","",""],["Chore::JsonEncoder","","classes/Chore/JsonEncoder.html","",""],["Chore::Lease","","classes/Chore/Lease.html","",""],["Chore::LockingSQSConsumer","","classes/Chore/LockingSQSConsumer.html","",""],["Chore::Manager","","classes/Chore/Manager.html","",""],["Chore::Pipe","","classes/Chore/Pipe.html","",""],["Chore::PipeListener","","classes/Chore/PipeListener.html","",""],["Chore::PipedStats","","classes/Chore/PipedStats.html","",""],["Chore::Publisher","","classes/Chore/Publisher.html","",""],["Chore::SQSConsumer","","classes/Chore/SQSConsumer.html","",""],["Chore::SQSPublisher","","classes/Chore/SQSPublisher.html","",""],["Chore::Semaphore","","classes/Chore/Semaphore.html","",""],["Chore::SingleConsumerStrategy","","classes/Chore/SingleConsumerStrategy.html","",""],["Chore::SingleWorkerStrategy","","classes/Chore/SingleWorkerStrategy.html","",""],["Chore::Stats","","classes/Chore/Stats.html","",""],["Chore::Tapjoy","","classes/Chore/Tapjoy.html","",""],["Chore::ThreadedConsumerStrategy","","classes/Chore/ThreadedConsumerStrategy.html","",""],["Chore::UnitOfWork","","classes/Chore/UnitOfWork.html","","<p>Simple class to hold job processing information. Has only three attributes:\n<p><code>:id</code> The queue implementation ...\n"],["Chore::Util","","classes/Chore/Util.html","",""],["Chore::Version","","classes/Chore/Version.html","",""],["Chore::Worker","","classes/Chore/Worker.html","","<p>Worker is one of the core classes in Chore. It’s responsible for most of\nthe logic relating to actually …\n"],["Chore::WorkerListener","","classes/Chore/WorkerListener.html","",""],["NewRelic","","classes/NewRelic.html","",""],["NewRelic::Agent","","classes/NewRelic/Agent.html","",""],["NewRelic::Agent::Instrumentation","","classes/NewRelic/Agent/Instrumentation.html","",""],["NewRelic::Agent::Instrumentation::ChoreInstrumentHook","","classes/NewRelic/Agent/Instrumentation/ChoreInstrumentHook.html","",""],["Object","","classes/Object.html","",""],["acquire","Chore::Semaphore","classes/Chore/Semaphore.html#method-i-acquire","(&block)",""],["add","Chore::PipedStats","classes/Chore/PipedStats.html#method-i-add","(stat,type=:global,data=nil)","<p>Override <code>add</code> to write data to the pipe instead of directly\ninto memory. This let’s us track stats  globally, …\n"],["add","Chore::Stats","classes/Chore/Stats.html#method-i-add","(stat,type=:global,data=nil)","<p>Add an entry to the stat list.\n<p><code>stat</code> should be the key of the stat to track.\n<p><code>type</code> should be the bucket ...\n"],["add_hook","Chore","classes/Chore.html#method-c-add_hook","(name,&blk)","<p>Add a global hook for <code>name</code>. Will run +&amp;blk+ when the hook\nis executed.  Global hooks are any hooks …\n"],["add_pipe","Chore::PipeListener","classes/Chore/PipeListener.html#method-i-add_pipe","(id)",""],["assign","Chore::ForkedWorkerStrategy","classes/Chore/ForkedWorkerStrategy.html#method-i-assign","(work)","<p>Take a UnitOfWork (or an Array of UnitOfWork) and assign it to a Worker. We\nonly assign work if there …\n"],["assign","Chore::Manager","classes/Chore/Manager.html#method-i-assign","(work)","<p>Take in an amount of <code>work</code> (either an Array of, or a single\nUnitOfWork), and pass it down for the worker …\n"],["assign","Chore::SingleWorkerStrategy","classes/Chore/SingleWorkerStrategy.html#method-i-assign","(work)",""],["available?","Chore::Semaphore","classes/Chore/Semaphore.html#method-i-available-3F","()",""],["close","Chore::Pipe","classes/Chore/Pipe.html#method-i-close","()","<p>Close both ends of the pipe\n"],["close_all","Chore::PipeListener","classes/Chore/PipeListener.html#method-i-close_all","()",""],["closed?","Chore::Pipe","classes/Chore/Pipe.html#method-i-closed-3F","()","<p>Is the pipe entirely closed? (Both read and write ends)\n"],["complete","Chore::Consumer","classes/Chore/Consumer.html#method-i-complete","(message_id)","<p>Complete should mark a message as finished. It takes a message_id as\nreturned via consume\n"],["complete","Chore::FilesystemConsumer","classes/Chore/FilesystemConsumer.html#method-i-complete","(id)",""],["complete","Chore::SQSConsumer","classes/Chore/SQSConsumer.html#method-i-complete","(id)",""],["config","Chore","classes/Chore.html#method-c-config","()","<p>Return the current Chore configuration as specified by\n<code>configure</code>. You can chain config options off of …\n"],["configure","Chore","classes/Chore.html#method-c-configure","(opts={})","<p>Configure global chore options. Takes a hash for <code>opts</code>. This\nincludes things like the current Worker  …\n"],["constantize","Chore::Util","classes/Chore/Util.html#method-i-constantize","(camel_cased_word)",""],["consume","Chore::Consumer","classes/Chore/Consumer.html#method-i-consume","(&block)","<p>Consume takes a block with an arity of two. The two params are\n|message_id,message_body| where message_id …\n"],["consume","Chore::FilesystemConsumer","classes/Chore/FilesystemConsumer.html#method-i-consume","(&handler)",""],["consume","Chore::LockingSQSConsumer","classes/Chore/LockingSQSConsumer.html#method-i-consume","(&handler)",""],["consume","Chore::SQSConsumer","classes/Chore/SQSConsumer.html#method-i-consume","(&handler)",""],["decode","Chore::JsonEncoder","classes/Chore/JsonEncoder.html#method-c-decode","(job)",""],["encode","Chore::JsonEncoder","classes/Chore/JsonEncoder.html#method-c-encode","(job)",""],["encode_job","Chore::Publisher","classes/Chore/Publisher.html#method-i-encode_job","(job)",""],["end_pipe","Chore::PipeListener","classes/Chore/PipeListener.html#method-i-end_pipe","(id)",""],["ensure_queue!","Chore::SQSPublisher","classes/Chore/SQSPublisher.html#method-i-ensure_queue-21","(name)",""],["fetch","Chore::SingleConsumerStrategy","classes/Chore/SingleConsumerStrategy.html#method-i-fetch","()",""],["fetch","Chore::ThreadedConsumerStrategy","classes/Chore/ThreadedConsumerStrategy.html#method-i-fetch","()",""],["filename","Chore::FilesystemPublisher","classes/Chore/FilesystemPublisher.html#method-i-filename","(queue_name, job_name)","<p>create a unique filename for a job in a queue based on queue name, job name\nand date\n"],["found_duplicate?","Chore::DuplicateDetector","classes/Chore/DuplicateDetector.html#method-i-found_duplicate-3F","(msg)",""],["get","Chore::Stats","classes/Chore/Stats.html#method-i-get","(stat,type=nil)","<p>Return the data about a particular stat.\n"],["handle_payload","Chore::PipeListener","classes/Chore/PipeListener.html#method-i-handle_payload","(payload)",""],["handle_payload","Chore::WorkerListener","classes/Chore/WorkerListener.html#method-i-handle_payload","(payload)","<p><code>handle_payload</code> is called in the master process for each\nmessage that comes across the pipe. It unmarshals ...\n"],["hooks_for","Chore","classes/Chore.html#method-c-hooks_for","(name)","<p>A helper to get a list of all the hooks for a given <code>name</code>\n"],["in_progress_dir","Chore::FilesystemQueue","classes/Chore/FilesystemQueue.html#method-i-in_progress_dir","(queue_name)",""],["job_hash","Chore::Job::ClassMethods","classes/Chore/Job/ClassMethods.html#method-i-job_hash","(job_params)","<p>Resque/Sidekiq compatible serialization. No reason to change what works\n"],["merge_hash","Chore::Configuration","classes/Chore/Configuration.html#method-i-merge_hash","(hsh={})",""],["new","Chore::CLI","classes/Chore/CLI.html#method-c-new","()",""],["new","Chore::Consumer","classes/Chore/Consumer.html#method-c-new","(queue_name, opts={})",""],["new","Chore::DuplicateDetector","classes/Chore/DuplicateDetector.html#method-c-new","(servers=nil,memcached_client = nil,timeout=0)",""],["new","Chore::FilesystemConsumer","classes/Chore/FilesystemConsumer.html#method-c-new","(queue_name, opts={})",""],["new","Chore::ForkedWorkerStrategy","classes/Chore/ForkedWorkerStrategy.html#method-c-new","(manager)",""],["new","Chore::Job","classes/Chore/Job.html#method-c-new","(args=nil)","<p>This is handy to override in an included job to be able to do job setup\nthat requires access to a job’s …\n"],["new","Chore::Lease","classes/Chore/Lease.html#method-c-new","(path, zookeeper)",""],["new","Chore::LockingSQSConsumer","classes/Chore/LockingSQSConsumer.html#method-c-new","(queue_name, opts={})",""],["new","Chore::Manager","classes/Chore/Manager.html#method-c-new","()",""],["new","Chore::Pipe","classes/Chore/Pipe.html#method-c-new","()",""],["new","Chore::PipeListener","classes/Chore/PipeListener.html#method-c-new","(timeout)",""],["new","Chore::PipedStats","classes/Chore/PipedStats.html#method-c-new","(pipe_id,listener,bucket_size=nil)","<p>PipedStats is a neat trick to avoid having to let our Worker know whether\nor not it’s running forked. …\n"],["new","Chore::Publisher","classes/Chore/Publisher.html#method-c-new","(opts={})",""],["new","Chore::SQSConsumer","classes/Chore/SQSConsumer.html#method-c-new","(queue_name, opts={})",""],["new","Chore::SQSPublisher","classes/Chore/SQSPublisher.html#method-c-new","(opts={})",""],["new","Chore::Semaphore","classes/Chore/Semaphore.html#method-c-new","(resource_name, zk, opts = {})",""],["new","Chore::SingleConsumerStrategy","classes/Chore/SingleConsumerStrategy.html#method-c-new","(fetcher, opts={})",""],["new","Chore::SingleWorkerStrategy","classes/Chore/SingleWorkerStrategy.html#method-c-new","(manager)",""],["new","Chore::Stats","classes/Chore/Stats.html#method-c-new","(max_bucket_size=1000)","<p>Stats is a class to hold current real-time information about what a chore\nprocess is up to. This includes …\n"],["new","Chore::ThreadedConsumerStrategy","classes/Chore/ThreadedConsumerStrategy.html#method-c-new","(fetcher)",""],["new","Chore::Worker","classes/Chore/Worker.html#method-c-new","(work=[],opts={})","<p>Create a Worker. Give it an array of work (or single item), and\n<code>opts</code>. Currently, the only option supported …\n"],["new","Chore::WorkerListener","classes/Chore/WorkerListener.html#method-c-new","(parent,timeout)","<p>The WorkerListener is a particular implementation of the PipeListener. It’s\nmodeled after NewRelic’s …\n"],["new","Object","classes/Object.html#method-c-new","(*args)",""],["new_dir","Chore::FilesystemQueue","classes/Chore/FilesystemQueue.html#method-i-new_dir","(queue_name)",""],["payload_class","Chore::Worker","classes/Chore/Worker.html#method-i-payload_class","(message)",""],["payload_class","NewRelic::Agent::Instrumentation::ChoreInstrumentHook","classes/NewRelic/Agent/Instrumentation/ChoreInstrumentHook.html#method-i-payload_class","(message)","<p>Override `payload_class` to take the new job class instance, and extend the\nabove instrumentation into …\n"],["perform","Chore::Job","classes/Chore/Job.html#method-i-perform","(*args)","<p>This needs to be overriden by the object that is including this module.\n"],["perform","Chore::Job::ClassMethods","classes/Chore/Job/ClassMethods.html#method-i-perform","(*args)","<p>Execute the current job. We create an instance of the job to do the perform\nas this allows the jobs …\n"],["perform_async","Chore::Job","classes/Chore/Job.html#method-i-perform_async","(*args)","<p>Use the current configured publisher to send this job into a queue.\n"],["perform_async","Chore::Job::ClassMethods","classes/Chore/Job/ClassMethods.html#method-i-perform_async","(*args)","<p>Publish a job using an instance of job. Similar to perform we do this so\nthat a job can perform initialization …\n"],["pipe_from_handle","Chore::PipeListener","classes/Chore/PipeListener.html#method-i-pipe_from_handle","(handle)",""],["prune!","Chore::PipeListener","classes/Chore/PipeListener.html#method-i-prune-21","()",""],["publish","Chore::FilesystemPublisher","classes/Chore/FilesystemPublisher.html#method-i-publish","(queue_name,job)","<p>use of mutex and file locking should make this both threadsafe and safe for\nmultiple processes to use …\n"],["publish","Chore::Publisher","classes/Chore/Publisher.html#method-c-publish","(queue_name,job)",""],["publish","Chore::Publisher","classes/Chore/Publisher.html#method-i-publish","(job)",""],["publish","Chore::SQSPublisher","classes/Chore/SQSPublisher.html#method-i-publish","(queue_name,job)",""],["queue_dir","Chore::FilesystemQueue","classes/Chore/FilesystemQueue.html#method-i-queue_dir","(queue_name)",""],["queue_options","Chore::Job::ClassMethods","classes/Chore/Job/ClassMethods.html#method-i-queue_options","(opts = {})","<p>Pass a hash of options to queue_options the included class’s use of\nChore::Job <code>opts</code> has a couple of required …\n"],["read","Chore::Pipe","classes/Chore/Pipe.html#method-i-read","()","<p>Does a sane pipe read looking for a Marshal safe separator. Ensures the\nother end of the pipe is closed. …\n"],["register_option","Chore::CLI","classes/Chore/CLI.html#method-c-register_option","(key,*args,&blk)","<p><code>register_option</code> is a method for plugins or other components to\nregister command-line config options. ...\n"],["register_tapjoy_handlers!","Chore::Tapjoy","classes/Chore/Tapjoy.html#method-c-register_tapjoy_handlers-21","()",""],["reject","Chore::Consumer","classes/Chore/Consumer.html#method-i-reject","(message_id)","<p>Reject should put a message back on a queue to be processed again later. It\ntakes a message_id as returned …\n"],["reject","Chore::FilesystemConsumer","classes/Chore/FilesystemConsumer.html#method-i-reject","(id)",""],["reject","Chore::SQSConsumer","classes/Chore/SQSConsumer.html#method-i-reject","(id)",""],["release","Chore::Lease","classes/Chore/Lease.html#method-i-release","()",""],["report","Chore::Manager","classes/Chore/Manager.html#method-i-report","()","<p>Generate data for the internal Chore stat server. Should return JSON data\nrepresenting the current state …\n"],["required_options","Chore::Job::ClassMethods","classes/Chore/Job/ClassMethods.html#method-i-required_options","()","<p>This is a method so it can be overriden to create additional required\nqueue_options params.\n"],["root_dir","Chore::FilesystemQueue","classes/Chore/FilesystemQueue.html#method-i-root_dir","()",""],["run!","Chore::CLI","classes/Chore/CLI.html#method-i-run-21","(args=ARGV)","<p>Start up the consuming side of the application. This calls both\nChore::Manager#start and the internal …\n"],["run_hooks_for","Chore","classes/Chore.html#method-c-run_hooks_for","(name,*args)","<p>Run the global hooks associated with a particular <code>name</code> passing\nall <code>args</code> to the registered block.\n"],["run_hooks_for","Chore::Hooks","classes/Chore/Hooks.html#method-i-run_hooks_for","(event,*args)","<p>Helper method to look up, and execute hooks based on an event name. Hooks\nare assumed to be methods defined …\n"],["running?","Chore::Consumer","classes/Chore/Consumer.html#method-i-running-3F","()",""],["running?","Chore::ThreadedConsumerStrategy","classes/Chore/ThreadedConsumerStrategy.html#method-i-running-3F","()",""],["set_worker_status","Chore::PipedStats","classes/Chore/PipedStats.html#method-i-set_worker_status","(id,*args)","<p>Override <code>set_worker_status</code> to write data to the pipe  instead\nof directly into memory.\n"],["should_stop?","Chore::PipeListener","classes/Chore/PipeListener.html#method-i-should_stop-3F","()",""],["shutdown","Chore::CLI","classes/Chore/CLI.html#method-i-shutdown","()",""],["shutdown!","Chore::Manager","classes/Chore/Manager.html#method-i-shutdown-21","()","<p>Shut down the Manager, the Worker Strategy, and the Fetcher. This calls the\n<code>:before_shutdown</code> hook.\n"],["start","Chore::ForkedWorkerStrategy","classes/Chore/ForkedWorkerStrategy.html#method-i-start","()","<p>Start up the worker strategy. In this particular case, what we’re doing is\nstarting up a WorkerListener …\n"],["start","Chore::Manager","classes/Chore/Manager.html#method-i-start","()","<p>Start the Manager. This calls both the #start method of the configured\nWorker Strategy, as well as Fetcher#start …\n"],["start","Chore::PipeListener","classes/Chore/PipeListener.html#method-i-start","()",""],["start","Chore::SingleWorkerStrategy","classes/Chore/SingleWorkerStrategy.html#method-i-start","()",""],["start","Chore::Worker","classes/Chore/Worker.html#method-i-start","()","<p>The workhorse. Do the work, all of it. This will block for an entirely\nunspecified amount of time based …\n"],["stop","Chore::Consumer","classes/Chore/Consumer.html#method-i-stop","()","<p>Perform any shutdown behavior and stop consuming messages\n"],["stop","Chore::PipeListener","classes/Chore/PipeListener.html#method-i-stop","()",""],["stop!","Chore::ForkedWorkerStrategy","classes/Chore/ForkedWorkerStrategy.html#method-i-stop-21","()","<p>Stop the workers. The particulars of the implementation here are that we\nsend a QUIT signal to each child, …\n"],["stop!","Chore::SingleConsumerStrategy","classes/Chore/SingleConsumerStrategy.html#method-i-stop-21","()",""],["stop!","Chore::ThreadedConsumerStrategy","classes/Chore/ThreadedConsumerStrategy.html#method-i-stop-21","()",""],["stop!","Chore::Worker","classes/Chore/Worker.html#method-i-stop-21","()","<p>Tell the worker to stop after it completes the current job.\n"],["to_json","Chore::Stats","classes/Chore/Stats.html#method-i-to_json","(*args)",""],["to_json","Chore::Worker","classes/Chore/Worker.html#method-i-to_json","(*args)","<p>This is used as part of the internal stat server. It let’s us track the\nstarting timestamp, and current …\n"],["wake_up!","Chore::PipeListener","classes/Chore/PipeListener.html#method-i-wake_up-21","()",""],["workers_available?","Chore::ForkedWorkerStrategy","classes/Chore/ForkedWorkerStrategy.html#method-i-workers_available-3F","()",""],["workers_available?","Chore::SingleWorkerStrategy","classes/Chore/SingleWorkerStrategy.html#method-i-workers_available-3F","()",""],["write","Chore::Pipe","classes/Chore/Pipe.html#method-i-write","(data)","<p>Does a sane pipe write with a Marshal safe separator. Ensures the other end\nof the pipe is closed. Should …\n"],["README","","files/README_rdoc.html","","<p># chore\n<p>## Integration\n<p>Chore can be integrated with any Ruby-based project by following these\ninstructions: …\n"]]}}